 /* ============================================================
   此JS用于总结js作用域的一些概念和代码解释（*代表重要的程度）
============================================================ */
 /**
  * 一:作用域基本概念
  */
 //1:引擎:负责js程序编译的整个过程
 //2:编译器：负责语法分析和代码生成
 //3:作用域：负责收集和维护由所有声明的变量组成的一系列查询，并严格根据规则，确定当前执行代码是否有权限访问这些标识符（变量）的访问权限(即当前代码是否有权限访问变量)
 //4:变量的赋值一般有两个操作：首先编译器会在当前的作用域中声明一个变量（如果之前没有声明过）；然后会在运行引擎的时候查找改变量，如果能够找到就赋值（*）
 //5:作用域嵌套：当一个块或函数嵌套在另一个块或函数中时,就发生了作用域的嵌套；如果该作用域无法找到该变量，就会外层嵌套查找，直到找到该变量，或抵达最外层的作用域(也就是全局作用域)为止（*）
 //6:深入理解RHS和LHS的区别：RHS：右查询,获取变量的值（即查找变量的值,如:console.info(a)）;LHS:左查询（赋值,即把变量定义在左边，如：var a=2;）（**）
 //7:嵌套作用域规则：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找，当抵达最外层的全局作用域时，无论找到还是没有找到，查找过程都会停止
 //8:ReferenceError:所有作用域都查不到所需的变量(和判断作用域有关);TypeError:对一个变量不合理的操作（比如对一个非函数类型进行函数调用）或引用null,undefinded类型的值中的属性（作用域判断成功，可是对结果操作的非法或者不合理）(***)
 /**
  * 总结：理解作用域；理解LHS,RHS查询
  * 目的是获取变量的值：使用RHS查询（取值）
  * 目的是赋值：使用LHS查询（=操作符或者调用函数传入参数的操作都会导致关联作用域的赋值操作）（赋值）
  */
 { //理解作用域的原理例子（重点理解引擎，编译器，作用域三者的对话）
   function foo(a) {
     console.log(a); // 2
   }
   foo(2);


 } 
 { //作用域嵌套（理解三者的对话）
   function foo(a) {
     console.log(a + b);
   }
   var b = 2;
   foo(2); // 4
 }

 /**
  * 二:词法作用域
  */
 //1:原理：由你在写代码时将变量和块级作用域写在哪里决定的！（词法分析器处理代码的时候会保存作用域不变***)
 //2:注意：无论函数在哪里被调用，也无论它是以怎样的形式调用，它的词法作用域都只由函数被声明时所处的位置决定的（**）
 //3:区别于动态作用域:动态作用域是根据调用者来决定其作用域的，比如this！
 //4:词法阶段:编译器的第一个阶段叫做词法分析，所以有词法作用域；词法作用域就是定义在词法阶段的作用域
 //5:eval和with可以用欺骗的方法修改作用域；eval如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with实际上是根据你所传递给它的对象凭空创造了一个全新的词法作用域
 //6:不用eval和with的原因:1:严格模式下会无效;2:虽然可以实现比较复杂的功能，可能性能不好，js引擎在编译的阶段就会进行优化，进行一些词法分析；并且预先确定变量的位置，才能在执行过程中快速找到标识符！

 { //词法作用域例子

   function foo(a) {
     var b = a * 2;

     function bar(c) {
       console.log(a, b, c);
     }
     bar(b * 3);
   }
   foo(2); // 2, 4, 12
 }

 { //欺骗作用域(eval)
   function foo(str, a) {
     eval(str); // 欺骗! console.log( a, b );
   }
   var b = 2;
   foo("var b = 3;", 1); // 1, 3
 }

 { //创建全新的作用域
   function foo(obj) {
     with(obj) {
       a = 2;
     }
   }
   var o1 = {
     a: 3
   };
   var o2 = {
     b: 3
   };
   foo(o1);
   console.log(o1.a); // 2
   foo(o2);
   console.log(o2.a); // undefined
   console.log(a); // 2——不好，a 被泄漏到全局作用域上了!
 }

 /**
  * 三:函数作用域和块作用域
  */
 //1:函数作用域:属于这个函数的全部变量都可以在整个函数的范围内被访问，嵌套在函数里面的函数也可以访问，在函数外面就不可以访问（即使是全局作用域气泡也不可以访问函数内部的变量）(***)
 //2:最小暴露原则：在声明函数和变量的时候，我们有必要把一些变量和函数定义在大函数内，不要定义在外部，不要定义在全局函数（也就是人们常说的函数和变量私有化），这有的设计更有利，有利于避免全局污染和函数私有化
 //3:隐蔽作用域的优点:避免定义一些相同的变量，特别是在定义全局变量的时候，需要小心，避免和函数内部的变量冲突了
 //4:函数声明：(function foo(){})(如果后面加一个括号就是立即执行函数声明:(function(){})()),这种方法方便了调用的操作，在函数声明完直接对函数的调用
 //5:函数表达式:function foo(){}
 //6：匿名函数表达式：setTimeout(function(){console.info("aaa")},1000)
 //7:行内函数表达式setTimeout(function name(){console.info("i have name!")},1000)
 //8:js的三种作用域：全局作用域，函数作用域，块作用域（let）（***）
 //

 { //不好的例子
   function doSomething(a) {
     b = a + doSomethingElse(a * 2);
     console.log(b * 3);
   }

   function doSomethingElse(a) {
     return a - 1;
   }
   var b;
   doSomething(2); // 15
 }

 { //最小暴露原则的例子
   function doSomething(a) {
     function doSomethingElse(a) {
       return a - 1;
     }
     var b;
     b = a + doSomethingElse(a * 2);
     console.log(b * 3);
   }
   doSomething(2); // 15
 }

 /**
  * 四:作用域理解的提升
  * 1:重要理解变量的声明和赋值的两个过程（声明是在编译阶段，赋值会停留在原地等待执行）：所以应该是先声明，后赋值
  * 2:原理：因为js对代码的处理分两个阶段，编译和运行；编译阶段只是找到所有的声明，并且把声明和作用域关联起来；而赋值只会在运行阶段执行
  * 3:只有声明会被提升，而赋值不会
  * 4:函数和变量一样，只有定义会提升;函数定义的优先级会比变量定义的优先级高
  */

 { //理解下面两个例子
   a = 2;
   var a;
   console.log(a);
 }

 {
   console.log(a);
   var a = 2;
 }

 { //函数例子：

   foo();

   function foo() {
     console.log(a); // undefined var a = 2;
   }

 }

 { //函数优先例子
   foo();
   var foo;

   function foo() {
     console.log(1);
   }
   foo = function() {
     console.log(2);
   };
 }
