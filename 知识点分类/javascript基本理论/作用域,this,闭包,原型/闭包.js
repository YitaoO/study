/* ============================================================
    此JS用于总结闭包的一些概念和代码解释（*代表重要的程度）
============================================================ */

function foo(){
  var a=2;
  function bar(){
    console.info(a)
  }
  bar()
}
var baz= foo()
baz() //输出2

//1:本来函数作用域在foo()执行后就会被销毁，可是bar()继续使用这个作用域，所以不会被释放
//2:bar()继续保持对这个作用域的引用，这个引用就叫做闭包
//3:闭包：一个内部函数依旧对某作用域的引用，就是闭包
//4:例子:定时器，事件监听器，ajax请求,跨窗口通信等其他异步任务中,只要用了回调函数，实质上就是闭包

for(var i=0;i<=5;i++){
  setTimeout(function(){
  console.info(i)
},i*1000);
} //输出五次6；而不是分别输出1-5

//5:延迟函数会在循环结束后才调用：也就是回调会在其他任务执行完才执行回调函数（***）

for(var i=0;i<=5;i++){
  (function(){
    var j=i;
    setTimeout(function(){
      console.info(j)
    },i*1000);
  })(i)
} //这样就可以输出 0-5

for(let i=0;i<=5;i++){
  let j=i;
  setTimeout(function timer(){
    console.info(j)
  },i*1000)
}  //最终解决方法，使用快作用域

//6:在迭代内使用IIFE会为每个迭代都生成一个作用域(上面有五个作用域,(function(){})()就是一个作用域)，如果再单独的作用域里面不设置变量，就是五个相同的作用域，这一点是很重要的（***）
//7：模块：必须有外部的封闭函数（该封闭函数必须至少调用一次，也就是实例化），封闭函数必须至少返回一个内部函数（这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的方法和属性）
//8:es6中模块的使用是使用 :export xxx和import hello from '.hello'来使用模块的（***）
