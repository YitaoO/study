/* ============================================================
    此JS用于总结this的一些概念和代码解释（*代表重要的程度）
============================================================ */
//1:this在任何情况下都不会指向词法作用域，使用this不可能再词法作用域只查到什么。所以this.bar()中并不能查到bar()词法作用域中的属性
//2:this是在运行时绑定的，而不是在在编写时绑定的(**)
//3:this的绑定和函数声明的位置没有任何关系，完全取决于函数在哪里被调用（而不是声明的位置）(**)
//4:基本概念：一个函数别调用时，会创建一个活动记录（执行上下文）,这个记录会有何时被调用，调用方式，传入的参数等信息，this就是这个记录的一个属性，会在函数执行的时候被调用
//4:调用栈：在开发者工具中断点：call stack中就可以看出当前函数的调用栈，如果想分析函数在上面地方调用，看调用栈中第二个元素，就知道在哪里调用（**）

/**
 * this绑定的四个规则
 */
//1:默认绑定:独立函数调用（无法用其他规则）;默认绑定中的this指向全局对象
//2：声明在全局作用域中的变量就是全局对象中的一个属性
//3:注意：函数中如果用严格模式的话，那么就不能用默认绑定,this就是是underfined
function foo(){
  console.info(this.a)
}
var a=1;
foo() //输出1

//3:隐私绑定:调用位置是否拥有上下文对象（也就是说是否被某个对象拥有或者包含）:隐私绑定会吧函数调用中的this绑定到这个上下文对象中（这里也就是obj对象）
//4：注意：对象属性引用链只有上一层或者最后一层在调用位置中起作用
function foo(){
  console.info(this.a)
}
obj={
  a:2,
  foo:foo
}
obj.foo() //输出2

//5:显示绑定：使用call（）或者apply()方法；把要绑定在哪个对象里面直接写在括号里面（比如foo.call(obj)）
function foo(){
  console.info(this.a)
}
obj={
  a:3
}
foo.call(obj)

//5:new绑定：
//6:注意：包括内置函数（比如:Number()）在内的所有函数都可以用new来实现，这种函数调用方式叫做构造函数调用（所以实际上并不存在所以的构造函数，只是对函数的够着调用）
//7:使用 new调用函数，会有四个过程（1：创建一个新的对象；2：这个新对象会 被执行[[Prototpye]]连接；3：这个新对象会绑定到函数调用的this;4:如果函数没有返回其他对象，呢么new表达式中的函数调用会自动返回这个新对象）(***)
function foo(a){
  this.a=a
}
var bar=new foo(3)
console.info(bar) //输出3

/**
 * 四个规则的优先级
 */
//1：是否有new，如果有的话this就绑定的是新创建的对象（var bar =new foo()）
//2:函数是否有call,apply(显示绑定)，如果有，this绑定到指定的对象(var bar =foo.call(obj))
//3:函数是否在某个上下文中调用（隐性绑定，也就是是否绑定到某个对象中）,如果是，this指向绑定的对象中(var bar =obj1.foo())
//4:如果都不是，就是默认绑定(var bar=foo())

//5:箭头函数并不会使用默认的四条规则，而是更具当前的词法作用域来决定this(也就是说箭头函数会根据外层函数调用的this绑定)，这种机制其实是和之前的self=this一样
