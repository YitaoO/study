 /* ============================================================
     此JS用于总结js作用域的一些概念和代码解释（*代表重要的程度）
 ============================================================ */
/**
 * 一:作用域基本概念
 */
//1:引擎:负责js程序编译的整个过程
//2:编译器：负责语法分析和代码生成
//3:作用域：负责收集和维护由所有声明的变量组成的一系列查询，并严格根据规则，确定当前执行代码是否有权限访问这些标识符（变量）的访问权限(即当前代码是否有权限访问变量)
//4:变量的赋值一般有两个操作：首先编译器会在当前的作用域中声明一个变量（如果之前没有声明过）；然后会在运行引擎的时候查找改变量，如果能够找到就赋值（*）
//5:作用域嵌套：当一个块或函数嵌套在另一个块或函数中时,就发生了作用域的嵌套；如果该作用域无法找到该变量，就会外层嵌套查找，直到找到该变量，或抵达最外层的作用域(也就是全局作用域)为止（*）
//6:深入理解RHS和LHS的区别：RHS：右查询,获取变量的值（即查找变量的值,如:console.info(a)）;LHS:左查询（赋值,即把变量定义在左边，如：var a=2;）（**）
//7:嵌套作用域规则：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找，当抵达最外层的全局作用域时，无论找到还是没有找到，查找过程都会停止
//8:ReferenceError:所有作用域都查不到所需的变量(和判断作用域有关);TypeError:对一个变量不合理的操作（比如对一个非函数类型进行函数调用）或引用null,undefinded类型的值中的属性（作用域判断成功，可是对结果操作的非法或者不合理）(***)
/**
 * 总结：理解作用域；理解LHS,RHS查询
 * 目的是获取变量的值：使用RHS查询（取值）
 * 目的是赋值：使用LHS查询（=操作符或者调用函数传入参数的操作都会导致关联作用域的赋值操作）（赋值）
 */

/**
 * 二:词法作用域
 */
//1:词法作用域：词法作用域是由你在写代码时将变量和块级作用域写在哪里决定的（词法分析器处理代码的时候会保存作用域不变***)
//2:无论函数在哪里被调用，也无论它是以怎样的形式调用，它的词法作用域都只由函数被声明时所处的位置决定的（**）
//3:eval和with可以用欺骗的方法修改作用域；eval如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with实际上是根据你所传递给它的对象凭空创造了一个全新的词法作用域


/**
 * 三:函数作用域和块作用域
 */
//1:函数作用域:属于这个函数的全部变量都可以在整个函数的范围内被访问，嵌套在函数里面的函数也可以访问，在函数外面就不可以访问（即使是全局作用域气泡也不可以访问函数内部的变量）(***)
//2:最小暴露原则：在声明函数和变量的时候，我们有必要把一些变量和函数定义在大函数内，不要定义在外部，不要定义在全局函数（也就是人们常说的函数和变量私有化），这有的设计更有利，有利于避免全局污染和函数私有化
//3:避免定义一些相同的变量，特别是在定义全局变量的时候，需要小心，避免和函数内部的变量冲突了
//4:函数声明：(function foo(){})(如果后面加一个括号就是立即执行函数声明:(function(){})()),这种方法方便了调用的操作，在函数声明完直接对函数的调用
//5:函数表达式:function foo(){}
//6：匿名函数表达式：setTimeout(function(){console.info("aaa")},1000)
//7:行内函数表达式setTimeout(function name(){console.info("i have name!")},1000)
//8:js的三种作用域：全局作用域，函数作用域，块作用域（let）（***）

/**
 * 四:作用域理解的提升
 */
//1:重要理解变量的声明和赋值的两个过程（声明是在编译阶段，赋值会停留在原地等待执行）：所以应该是先声明，后赋值
 a=2;
 var a;
 console.info(a) //输出2

 console.info(a)
 var a=2; //输出undefined

 //2:只有函数声明会被提升，赋值只会停留在原地
 //3:函数声明和变量声明都会被提升（函数会首先被提升，然后才是变量）（***）
